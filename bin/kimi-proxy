#!/bin/bash
# =============================================================================
# Kimi Proxy Dashboard - Commande principale
# =============================================================================

set -e

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Répertoire du projet
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
VENV_DIR="$PROJECT_DIR/venv"
PID_FILE="$PROJECT_DIR/.server.pid"

# =============================================================================
# Fonctions utilitaires
# =============================================================================

show_help() {
    cat << EOF
Kimi Proxy Dashboard - Outil de monitoring temps réel pour LLM

Usage: kimi-proxy <command> [options]

Commandes:
    start       Démarre le serveur
    stop        Arrête le serveur
    restart     Redémarre le serveur
    status      Affiche le statut du serveur
    logs        Affiche les logs du serveur
    test        Lance les tests
    shell       Ouvre un shell Python avec l'environnement chargé
    help        Affiche cette aide

Options pour start:
    --host      Host à écouter (défaut: 0.0.0.0)
    --port      Port à écouter (défaut: 8000)
    --reload    Active le reload automatique

Exemples:
    kimi-proxy start              # Démarre sur le port 8000
    kimi-proxy start --port 9000  # Démarre sur le port 9000
    kimi-proxy status             # Vérifie si le serveur tourne

EOF
}

log_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

log_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

log_error() {
    echo -e "${RED}❌ $1${NC}"
}

# =============================================================================
# Commandes
# =============================================================================

cmd_start() {
    local host="0.0.0.0"
    local port="8000"
    local reload=""
    
    # Parse les arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --host)
                host="$2"
                shift 2
                ;;
            --port)
                port="$2"
                shift 2
                ;;
            --reload)
                reload="--reload"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Vérifie si déjà en cours d'exécution
    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE")
        if ps -p "$pid" > /dev/null 2>&1; then
            log_warning "Le serveur tourne déjà (PID: $pid)"
            log_info "Utilisez 'kimi-proxy restart' pour redémarrer"
            exit 1
        else
            rm -f "$PID_FILE"
        fi
    fi
    
    # Vérifie l'environnement virtuel
    if [ ! -d "$VENV_DIR" ]; then
        log_warning "Environnement virtuel non trouvé, création..."
        python3 -m venv "$VENV_DIR"
        source "$VENV_DIR/bin/activate"
        pip install -q fastapi uvicorn httpx websockets tiktoken aiofiles
    else
        source "$VENV_DIR/bin/activate"
    fi
    
    # Chargement des variables d'environnement depuis .env
    if [ -f ".env" ]; then
        log_info "Chargement des variables d'environnement depuis .env..."
        # Exporte les variables sans les guillemets
        while IFS='=' read -r key value; do
            # Ignore les lignes vides et les commentaires
            [[ -z "$key" || "$key" =~ ^# ]] && continue
            # Supprime les espaces et guillemets
            key=$(echo "$key" | xargs)
            value=$(echo "$value" | sed 's/^["'\''"]//;s/["'\''"]$//' | xargs)
            export "$key=$value"
        done < .env
    else
        log_warning "Fichier .env non trouvé"
    fi
    
    log_info "Démarrage du serveur sur $host:$port..."
    
    # Démarre le serveur en arrière-plan
    cd "$PROJECT_DIR"
    PYTHONPATH="$PROJECT_DIR/src:$PYTHONPATH" \
        uvicorn kimi_proxy.main:app \
        --host "$host" \
        --port "$port" \
        $reload \
        > "$PROJECT_DIR/server.log" 2>&1 &
    
    local server_pid=$!
    echo $server_pid > "$PID_FILE"
    
    # Attend que le serveur démarre
    sleep 2
    
    if ps -p "$server_pid" > /dev/null 2>&1; then
        log_success "Serveur démarré (PID: $server_pid)"
        log_info "Dashboard: http://localhost:$port"
        log_info "Logs: tail -f $PROJECT_DIR/server.log"
    else
        log_error "Échec du démarrage du serveur"
        rm -f "$PID_FILE"
        exit 1
    fi
}

cmd_stop() {
    if [ ! -f "$PID_FILE" ]; then
        log_warning "Aucun serveur en cours d'exécution"
        exit 0
    fi
    
    local pid=$(cat "$PID_FILE")
    
    if ps -p "$pid" > /dev/null 2>&1; then
        log_info "Arrêt du serveur (PID: $pid)..."
        kill "$pid" 2>/dev/null || true
        
        # Attend que le processus s'arrête
        local count=0
        while ps -p "$pid" > /dev/null 2>&1 && [ $count -lt 10 ]; do
            sleep 1
            ((count++))
        done
        
        if ps -p "$pid" > /dev/null 2>&1; then
            log_warning "Forçage de l'arrêt..."
            kill -9 "$pid" 2>/dev/null || true
        fi
        
        log_success "Serveur arrêté"
    else
        log_warning "Le serveur ne tourne plus"
    fi
    
    rm -f "$PID_FILE"
}

cmd_restart() {
    log_info "Redémarrage du serveur..."
    cmd_stop
    sleep 1
    cmd_start "$@"
}

cmd_status() {
    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE")
        if ps -p "$pid" > /dev/null 2>&1; then
            log_success "Serveur actif (PID: $pid)"
            
            # Vérifie si le port répond
            if curl -s http://localhost:8000/health > /dev/null 2>&1; then
                log_success "Dashboard accessible sur http://localhost:8000"
            else
                log_warning "Dashboard ne répond pas encore"
            fi
        else
            log_error "Le serveur ne tourne plus (PID fantôme: $pid)"
            rm -f "$PID_FILE"
        fi
    else
        log_info "Aucun serveur en cours d'exécution"
    fi
}

cmd_logs() {
    local log_file="$PROJECT_DIR/server.log"
    
    if [ -f "$log_file" ]; then
        tail -f "$log_file"
    else
        log_error "Fichier de log non trouvé: $log_file"
        exit 1
    fi
}

cmd_test() {
    log_info "Lancement des tests..."
    
    if [ -d "$VENV_DIR" ]; then
        source "$VENV_DIR/bin/activate"
    fi
    
    cd "$PROJECT_DIR"
    
    if [ -f "$PROJECT_DIR/tests/e2e/test_regression.py" ]; then
        PYTHONPATH="$PROJECT_DIR/src:$PYTHONPATH" python -m pytest tests/ -v
    else
        log_warning "Tests non trouvés, lancement des tests basiques..."
        bash "$PROJECT_DIR/test_dashboard.sh"
    fi
}

cmd_shell() {
    if [ -d "$VENV_DIR" ]; then
        source "$VENV_DIR/bin/activate"
    fi
    
    cd "$PROJECT_DIR"
    PYTHONPATH="$PROJECT_DIR/src:$PYTHONPATH" python
}

# =============================================================================
# Main
# =============================================================================

main() {
    case "${1:-help}" in
        start)
            shift
            cmd_start "$@"
            ;;
        stop)
            cmd_stop
            ;;
        restart)
            shift
            cmd_restart "$@"
            ;;
        status)
            cmd_status
            ;;
        logs)
            cmd_logs
            ;;
        test)
            cmd_test
            ;;
        shell)
            cmd_shell
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            log_error "Commande inconnue: $1"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

main "$@"
